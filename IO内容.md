**传统的IO模型**：(阻塞IO模型)

?		在读取数据的过程中会发生阻塞现象，用户线程发出IO请求之后， 内核就会去检查数据是否就绪，如果没有就绪 ， 就会等待数据就绪，并且用户线程会处于阻塞状态，用户线程就会交出CPU， 当数据准备就绪之后，内核就会将数据拷贝到用户线程，并返回结果给用户线程。用户线程就会解除block状态，如果数据没有就绪，就会一直阻塞在read方法。典型的阻塞IO模型：

```java
data = socket.read();
```





**非阻塞IO模型**：

?		当用户线程发起一个read操作后，不需要等待，马上得到一个结果，如果结果是error，就说明数据没有准备就绪，那就可以再次发送read操作，一旦内核中数据准备就绪，并且又再次接收到用户线程的请求，内核就会把数据拷贝到用户线程，然后返回，事实上，在非阻塞IO模型中，用户线程需要不断的向内核询问数据是否准备就绪，也就是说非阻塞IO模型不会交出CPU，而会一直占用CPU，典型的非阻塞IO模型一般如下：

```java
while(true){
    data = socket.read();
    if(data!=error){
        //处理数据
        break;
    }
}
```

对于非阻塞IO有一个非常严重的问题，在while循环中需要不断的询问内核数据是否准备就绪，这样会导致CPU 占用率非常高，一般情况下很少使用while循环来读取数据

**NIO（non-blocking IO）**:

多路复用IO模型是目前使用得比较多的模型，在NIO模型中，有一个线程不断的去轮询多个socket的状态，只有当socket真正有读写事件的时候，才真正调用实际的IO读写操作，在多路复用IO模型中，只要有一个线程就可以管理多个socket，系统不需要建立新的进程或线程，也不必维护这些进程或线程，只有真正有socket读写事件进行时，才会使用IO资源，所以大大减少了资源的占用。在NIO模型中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，就一直阻塞在那里，因此这种方法会导致用户线程的阻塞。

**NIO三大核心部分**：Channel（通道）、Buffer（缓冲区）、Selector（选择区）

数据总是从通道读取到缓冲区，或者从缓冲区写入到通道。

传统的IO操作面向数据流，意味着每次从流中读取一个或多个字节，直至完成，数据没有被缓存在任何地方，

NIO操作面向缓冲区，数据从通道中读取到缓冲区，随后在缓冲区处理数据。

buffer缓冲区实质上就是一块内存 ，用于写入数据，也供后续再次读取数据，这块内存被NIO Buffer管理，并提供一系列的方法用于简单的操作这块内存。一个Buffer有三个属性：容量、位置、限制

NIO Channel通道和流非常相似，区别如下：

+ 通道可以读 可以写，流一般来说 是单向的 （只能读或写）
+ 通道可以异步读写
+ 通道总是基于缓冲区Buffer来读写

Selector是对于多个非阻塞IO流的调度器，通过Selector 来实现读写操作。用于检查一个或多个NIO  Channel的状态是否处于可读或者可写，如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。



